//// Created by sapiest on 05.10.2019.//#pragma once#include <chrono>#include <thread>#include "../../src/Utils/Headers/CommonUtils.h"#include "../../src/Utils/Headers/Constants.h"#include "gtest/gtest.h"class TestUtils {   public:    static void clear() {        std::string command;        std::string command2;#ifdef __WIN32        const char *delete_command = "del ..\\Server\\";        const char *delete_command2 = "del ..\\Tests\\";#else        const char *delete_command = "rm -rf ../Server/";#endif        std::string name = "*" + Constants::FILE_TYPE;        command = delete_command + name;        command2 = delete_command2 + name;        std::system(command.c_str());        std::system(command2.c_str());    }    static void kill() {        const std::string name_ = "Server";        std::string command;#ifdef __WIN32        command = "taskkill /IM " + name_ + ".exe /F";#elif __linux        command = "killall -KILL " + name_;#endif        std::system(command.c_str());    }    static void run() {        const std::string name_ = "Server";        const std::string directory_ = "..\\Server\\";        std::string command;#ifdef __WIN32        command = "start cmd.exe /c \"" + directory_ + name_ + ".exe\"";#elif __linux        command = "cd " + directory_ + " && ./" + name_ + " ; cd -";#endif        std::system(command.c_str());    }    static void checkRequests(const std::vector<std::pair<std::string, std::string>> &requests) {        Client client;        for (const auto &request : requests) {            client.execRequest(request.first);            EXPECT_EQ(client.response, request.second);        }    }    static void    checkDrop(const std::pair<std::pair<std::string, std::string>, std::pair<std::string, std::string>> &request) {        bool runTest = true;        int timeKill = 0;        while (runTest) {            bool checkTest = false;            Client client;            client.sendMessage(request.first.first);            std::this_thread::sleep_for(std::chrono::milliseconds(timeKill));            kill();            run();            Client clientNew;            clientNew.execRequest(request.first.second);            if (clientNew.response == request.second.first or clientNew.response == request.second.second) {                checkTest = true;            }            EXPECT_EQ(checkTest, true);            if (clientNew.response == request.second.second) {                break;            }            if (timeKill > 500) {                EXPECT_EQ("Time out", "");                break;            }            timeKill += 10;            break;        }    }};